# -*- coding: utf-8 -*-
"""inverse_kinematics_implementation.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1JsXaHUUfQOwBAcN9p2r2JTRiwGes404n
"""

import numpy as np
from numpy import dot, matrix, deg2rad, cross
from math import pi
import math
from math import cos, sin, acos, asin

"""input data: DH parameters of kuka iiwa7, initial theta angles, end effector position transformation matrix."""

# def r2d(x):
#   return x*180/pi

d_bs, d_se, d_ew, d_wf = 340, 400, 400, 126
d = np.array([d_bs, 0, d_se, 0, d_ew, 0, d_wf])
# theta = np.array([d2r(-115.8158), d2r(107.2721),d2r(0),d2r(75),d2r(-143.2641),d2r(25.8884),d2r(-90.9575)])
theta = np.array([deg2rad(30), deg2rad(-45), deg2rad(60), deg2rad(75), deg2rad(-20), deg2rad(95), deg2rad(-80)])
# theta = np.array([deg2rad(0), deg2rad(0),deg2rad(0),deg2rad(0),deg2rad(0),deg2rad(0),deg2rad(0)])
alpha = np.array([-pi / 2, pi / 2, pi / 2, -pi / 2, -pi / 2, pi / 2, 0])
a = np.array([0, 0, 0, 0, 0, 0, 0])
dh_parameters = [[a[0], alpha[0], d[0], theta[0]], [a[1], alpha[1], d[1], theta[1]], [a[2], alpha[2], d[2], theta[2]],
                 [a[3], alpha[3], d[3], theta[3]], [a[4], alpha[4], d[4], theta[4]], [a[5], alpha[5], d[5], theta[5]],
                 [a[6], alpha[6], d[6], theta[6]]]
dh_parameters = np.matrix(dh_parameters)
print("DH_parameters")
print(dh_parameters)
print("\n")
print("input angles theta1 to theta 7 in degrees")
print(np.rad2deg(theta))

""""DH transformation matrix" function"""


def DH(angles, joint):
    # angles = np.rad2deg(angles)
    DH = [[cos(angles[joint]), -(sin(angles[joint]) * cos(alpha[joint])), sin(angles[joint]) * sin(alpha[joint]),
           a[joint] * cos(angles[joint])],
          [sin(angles[joint]), cos(angles[joint]) * cos(alpha[joint]), -(cos(angles[joint]) * (sin(alpha[joint]))),
           a[joint] * sin(angles[joint])],
          [0, sin(alpha[joint]), cos(alpha[joint]), d[joint]],
          [0, 0, 0, 1]]
    DH = np.matrix(DH)
    return DH


""""Transformation chain"  function"""


def transformation(angles, joints):
    temp3 = np.array([[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]])
    temp3 = np.matrix(temp3)
    for i in range(joints):
        temp3 = dot(temp3, DH(angles, i))
    return temp3


"""Global Configuration"""


def gc(i):  # theta2 is gc(1); theta4 is gc(3); theta6 is gc(5)
    if (theta[i] >= 0):
        return 1
    else:
        return -1


"""FORWARD KINEMATICS  _  


---


 0 to 7 - base to end effector transformation matrix _
"""
print("\n")
print("transformations 0  to  7 --> T07 using FORWARD KINEMATICS")
print(transformation(theta, 7))

T07 = transformation(theta, 7)
R07 = matrix(T07[:3, :3])
P07 = matrix(T07[:3, 3])

P02 = matrix([0, 0, d_bs]).T
P24 = matrix([0, d_se, 0]).T
P46 = matrix([0, 0, d_ew]).T
P67 = matrix([0, 0, d_wf]).T

P26 = P07 - P02 - dot(R07, P67)

"""virtual theta 4"""


def mag(x):
    return math.sqrt(sum(i ** 2 for i in x))


k = (mag(P26) ** 2 - d_se ** 2 - d_ew ** 2) / (2 * d_se * d_ew)
theta4_v = gc(3) * acos(k)

"""virtual theta 1"""

R01 = DH(theta, 0)[:3, 2:3]
#print(R01)
alignment = mag(np.cross(P26, R01, axis=0))  # axis = 0 because R01 and P26 are column vectors
#print(alignment)

if alignment > 0:
    theta1_v = math.atan2(P26[1:2], P26[0:1])
elif alignment == 0:
    theta1_v = 0

"""calculating Phi for Virtual Theta 2"""

phi = math.acos((d_se ** 2 + (mag(P26)) ** 2 - d_ew ** 2) / (2 * d_se * (mag(P26))))
theta2_v = math.atan2(math.sqrt((P26[0:1]) ** 2 + (P26[1:2]) ** 2), P26[2:3]) + gc(3) * phi

#print(phi)
#print(theta2_v)

"""Theta Virtual 3, this angle is kept zero so we can convert 7dof robot into a 6 dof robot"""

theta3_v = 0

"""virtual angles

---


ASSEMBLE
"""

theta_v = np.array([theta1_v, theta2_v, theta3_v, theta4_v])
print("\n")
print("virtual angles theta1_v,  theta2_v, theta3_v, theta4_v in degrees")
print(np.rad2deg(theta_v))

"""Psi angle, the angle between the "virtual elbow" and "real elbow" wrt shoulder-wrist axis"""

P02_v = transformation(theta_v, 2)[0:3, 3:4]
P02 = transformation(theta, 2)[0:3, 3:4]

P04_v = transformation(theta_v, 4)[0:3, 3:4]
P04 = transformation(theta, 4)[0:3, 3:4]

P06 = transformation(theta, 6)[0:3, 3:4]
P06_v = P06

j = P04_v - P02_v
q = P06_v - P02_v
normal_virtual_sew = np.cross(((j) / mag(j)), ((q) / mag(q)), axis=0)

j = P04 - P02
q = P06 - P02
normal_real_sew = np.cross(((j) / mag(j)), ((q) / mag(q)), axis=0)
#print((j) / mag(j))
#print(q / mag(q))
#print(normal_real_sew)

mod_real_sew = np.linalg.norm(normal_real_sew)
mod_virtual_sew = np.linalg.norm(normal_virtual_sew)

# adding below if condition to prevent zero division error by replacing zero with very small number
if mod_real_sew == 0:
    mod_real_sew = 0.0000000000000001
if mod_virtual_sew == 0:
    mod_virtual_sew = 0.0000000000000001

normal_virtual_sew_hat = normal_virtual_sew / mod_virtual_sew
normal_real_sew_hat = normal_real_sew / mod_real_sew
#print(normal_real_sew)

g = np.cross((normal_virtual_sew_hat), (normal_real_sew_hat), axis=0)
g = dot(g.T, P26)

if g >= 0:
    g = 1
elif g < 0:
    g = -1

psi = g * math.acos(dot(normal_virtual_sew_hat.T, normal_real_sew_hat))
#print(psi)

"""INVERSE KINEMATICS"""


def skew(x):
    return np.matrix([[0, -x.item(2), x.item(1)],
                      [x.item(2), 0, -x.item(0)],
                      [-x.item(1), x.item(0), 0]])


P26_hat = P26 / mag(P26)
print("\n")
print("P26_hat")
print(P26_hat)

P26_skew = skew(P26_hat)

R03_v = transformation(theta_v, 2)[0:3, 0:3]
print("\n")
print("R03_virtual")
print(R03_v)

As = np.matmul(P26_skew, R03_v)
Bs = -1 * np.matmul((P26_skew ** 2), R03_v)
Cs = np.matmul((np.matmul(P26_hat, P26_hat.T)), R03_v)

print("\n")
print("As, Bs and Cs")
print(As)
print(Bs)
print(Cs)

"""Obtaining R03 for theta_real1, theta_real2, theta_real3"""

R03 = As * sin(psi) + Bs * cos(psi) + Cs

As[2, 1] * sin(psi) + Bs[2, 1] * cos(psi) + Cs[2, 1]

theta1_r = math.atan2(gc(1) * (As[1, 1] * sin(psi) + Bs[1, 1] * cos(psi) + Cs[1, 1]),
                      gc(1) * (As[0, 1] * sin(psi) + Bs[0, 1] * cos(psi) + Cs[0, 1]))
theta2_r = gc(1) * math.acos(As[2, 1] * sin(psi) + Bs[2, 1] * cos(psi) + Cs[2, 1])
theta3_r = math.atan2(gc(1) * (-As[2, 2] * sin(psi) - Bs[2, 2] * cos(psi) - Cs[2, 2]),
                      gc(1) * (-As[2, 0] * sin(psi) - Bs[2, 0] * cos(psi) - Cs[2, 0]))
theta4_r = theta4_v

"""REAL ANGLES

---
ASSEMBLE
"""

theta_r = np.array([theta1_r, theta2_r, theta3_r, theta4_r])

R34 = DH(theta_r, 3)[0:3, 0:3]

Aw = R34.T * As.T * R07
Bw = R34.T * Bs.T * R07
Cw = R34.T * Cs.T * R07
print("\n")
print("Aw, Bw and Cw")
print(Aw)
print(Bw)
print(Cw)


R47 = Aw * sin(psi) + Bw * cos(psi) + Cw

theta5_r = math.atan2((gc(5) * (Aw[1, 2] * sin(psi) + Bw[1, 2] * cos(psi) + Cw[1, 2])),
                      (gc(5) * (Aw[0, 2] * sin(psi) + Bw[0, 2] * cos(psi) + Cw[0, 2])))
theta6_r = gc(5) * math.acos(Aw[2, 2] * sin(psi) + Bw[2, 2] * cos(psi) + Cw[2, 2])
theta7_r = math.atan2((gc(5) * (Aw[2, 1] * sin(psi) + Bw[2, 1] * cos(psi) + Cw[2, 1])),
                      (gc(5) * (- Aw[2, 0] * sin(psi) - Bw[2, 0] * cos(psi) - Cw[2, 0])))

theta_r = np.append(theta_r, theta5_r)
theta_r = np.append(theta_r, theta6_r)
theta_r = np.append(theta_r, theta7_r)

print("\n")
print("Real angles theta_real_1 to theta_real_7 in degrees obtained after INVERSE KINEMATICS")
print(np.rad2deg(theta_r))

"""Testing the obtained real angles after INVERSE KINEMATICS"""

# "theta_r" contains obtained real angles after IK
print("\n")
print("transformation matrix from the real angles obtained after INVERSE KINEMATICS")
print(transformation(theta_r, 7))
